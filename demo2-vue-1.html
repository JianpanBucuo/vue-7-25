<!DOCTYPE html>
<html>
<head>
<script type="text/javascript" src="js/vue.js"> </script>
<link rel="stylesheet" type="text/css" href="css/style.css">
	<title></title>
</head>
<body>
<span v-text="msg"></span>
<!-- 等同于 -->
<span>{{msg}}</span>
<button v-on="{mousedown:doThis,mouseup:doThat}"></button>
 <div id="app">
 	<ol>
 		<todo-item
          v-for="item in groceryList"
          v-bind:todo="item"
          v-bind:key="item.id"
 		></todo-item>
 	</ol>
 </div>
 
我们可以将同一函数定义为一个方法而不是一个计算属性。
两种方式的最终结果确实是完全相同的。
然而，不同的是计算属性是基于它们的依赖进行缓存的。
只有相关依赖发生改变时才会重新求职。
这就意味着只要msssage还没有发生改变，多次访问reversedMessage计算属性会立即返回之前的计算结果。
而不必再次执行函数。
相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。


<script type="text/javascript" src="js/script.js"> </script>
<script type="text/javascript">
 Vue.component("todo-item",{
 	props:["todo"],
 	template:`<li>{{todo.text}}</li>`
 })

var app=new Vue({
	el:"#app",
	data:{
		groceryList:[
          {id:0,text:"aaa"},
          {id:1,text:"bbb"},
          {id:2,text:"ccc"},
          {id:3,text:"ddd"}
		]
	}
})

Vue.component("props-demo-simple",{
	props:{
		height:Number,
		age:{
			type:Number,
			default:0,
			required:true,
			validator:function(value){
               return vaule >= 0;
			}
		}
	}
})
//生命周期钩子
new Vue({
	data:{
		a:1
	},
	created:function() {
		console.log(this.data);
	}
})
//在实例创建完成后立即调用，在这一步，实例以完成以下的配置：
//数据观测(data observer)，属性和方法的运算，watch/event事件回调，
//然而，挂载阶段还没开始

let vm = new Vue({
	data:{
		a:1,
		b:2,
		c:3,
		d:4,
		e:{
			f:{
				g:5
			}
		}
	},
	watch:{
		a:function(oldValue,newValue) {},
		b:"someMethod",
		c:{
			handler:function(oldValue,newValue){},
			immediate:true
			//watch的一个特点是，最初绑定的时候是不会执行的，要的等到firstName改变时
			//采执行监听计算，那我们想要一开始就让他最初绑定的时候就执行该怎么办呢？

		},
		d:{
			handler:function(oldValue,newValue){

			},
			deep:true
			//是否深度监听
		}
	}
})



</script>
</body>
</html>